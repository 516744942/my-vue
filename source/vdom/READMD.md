### vDom 虚拟dom

#### 什么是虚拟dom 1
1. 早起没有那么复杂的状态需要管理
2. 也不需要频繁地操作DOM
3. 使用jQuery来开发就可以满足我们的需求
4. 状态和DOM操作越来越频繁
5. 拽台作为输入,并生成DOM输出到页面上显示出来,这个过程叫做渲染
6. 程序运行时,状态会不断发生改变,引起状态变化, 都需要重新
7. 如和确定状态发生了什么变化,哪里需要更新DOM
8. 简单方法是,只需要吧所有DOM全删除,然后使用状态后重新生成一份DOM,输入到页面上
9. 但是所有访问DOM是非常昂贵的,按照上面说的方法,会造成相当多的性能浪费
10. 状态变化通常只有有限的几个节点需要重新渲染,所以我们不仅需要找出哪里需要更新,还需要尽量可能少的访问dom
11. 当某个状态发生变化时,只更新与这个状态相关联的DOM节点
12. vuejs 1.0通过细粒度绑定
13. 虚拟dom本质上只是众多解决方案中的一种

####  什么是虚拟dom 2
1. 虚拟dom的解决方案是通过状态生成一个虚拟节点树
2. 然后使用虚拟节点树进行渲染
3. 在渲染之前,会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比,只渲染不同的部分

#### 为什么要引入虚拟DOM
1. Angular和React的变化侦测有一个共同点,那就是他们都不知道那些状态(state)变了
2. 因此,就需要暴力比对,React就是通过虚拟DOM的比较,Angular是使用脏检查
3. vue1.0通过细力度的绑定更新实图
4. 一个状态一个watcher观察的变化,这样就会有一些内存开销以及一些依赖来追踪的开销
5. vue2.0开始选择一个中等粒度的解决方案
6. 那就引入瞭虚拟DOM
7. 组件级别是一个watcher实例,一个组件内部有10个节点状态使用瞭某个状态,但是也只有一个watcher在观察这个状态变化
8. 只能通知到组件,然后组件内部通过虚拟DOM去进行对比渲染,这是一个比较折中的方案


### vue.js中的虚拟DOm
1. 使用模版来描述状态与DOM之间的映射关系
2. vuejs通过编译将模版转换成渲染函数(render)
3. 执行一个渲染函数就可以得到一个虚拟节点树
4. 使用这个虚拟树就可以渲染成页面
5. 模版(编译)->渲染函数(执行)->虚拟DOM(Vnode(patch)->视图)
6. instance-> 一个ul标签下有很多li标签,其中一个li有变化,这种情况下下替换ul,其实只要替换变化的li节点
7. 原因:由于DOM操作比较慢,所以这些DOm操作在性能上有一定的浪费,
8. 避免这些DOM操作会提升一大部分性能
9. 为了避免不必要的DOM操作,
10. 虚拟DOm在虚拟节点映射到实图过程中,
11. 找出真正需要更新的节点来进行DOM操作
12. 从而避免操作其他无任何改动的DOM
## 虚拟主要做两件事
1. 提供与真实DOM芥蒂娜所对应的虚拟节点VNode
2. 将虚拟节点vnode和旧虚拟解节点oldNode进行比对,然后更新识图
### vnode
1. vnode是javaScript中一个很普通的对象
2. 这个对象的属性上保存瞭生成DOM节点所需要的一些数据
3. 对两个虚拟DOm进行对比(patch)算法
4. 它可以判断樗那些节点发生了变化,从而支队发生变化的节点进行更新操作